**优化mysql的配置通常比询问我的服务器最佳配置文件是什么更加重要**

配置文件通常位于

```ini
/etc/my.cnf

or

/etc/mysql/my.cnf
```

#### 语法,作用域和动态性

在命令行中指定参数通常**不区分单词之间的是下划线还是中划线**

```bash
/usr/sbin/mysqld --auto-increment-offset=5

等效

/usr/sbin/mysqld --auto_increment_offset=5
```

#### 持久化系统变量

如果**重启**mysql,**即使使用了`set global`来更改全局变量**,mysql也会**恢复到配置文件中**的状态

8.0中引入了持久化系统变量的新功能

`set persist`命令允许在**运行时设置值**,mysql会将这个值**写入磁盘**,下次重启也将**继续使用**该值

#### 设置变量的副作用

在运行时设置变量会产生意想不到的副作用,导致服务器执行大量的工作

> 尽量避免动态设置变量

#### 创建mysql配置文件

>  每台服务器,每个生产环境,每个种业务模式都会产生出一种不同的最佳配置,即便服务器配置一样.一个良好的配置应该是自己调试得来,而不是咨询

##### 最小化配置

```init
[mysqld]
#通用配置
#GENERAL

datadir  mysql数据存放位置
socket   指定客户端连接到mysql服务器使用的套接字文件路径
pid_file mysql服务器进程ID存储位置
user     mysql启动用户
port     mysql启动端口

#innodb引擎配置
#INNODB
*非常重要innodb_buffer_pool_siez   innoDB缓冲池大小
innodb_log_file_size      innoDB日志文件大小
innodb_flush_method       指定innodb将数据刷新到磁盘上的方式

#LOGGING
...

#OTHER
tmp_table_size     指定存储中创建的临时表的最大size
max_heap_table_size 指定堆中临时表最大size
max_connections     最大连接数
thread_cahce_size   指定线程缓存的大小
table_open_cache    控制缓存打开表文件的数量
open_files_limit    指定单个进程同时打开文件数量的上限

[client]
socket
prot
```

#### 配置内存使用

>`innodb_dedicated_server`通常会占用**50%~75%**的内存,说明至少由25%的内存可用于每个连接的内存分配,操作系统开销和其他内存设置

##### 每个连接的内存需求

mysql保持连接只需要少量的内存 + 基本内存量来执行给定查询

> 连接存储*N + 查询内存

*在预测内存时**不需要假设最坏**的情况*

使用许多**大型临时表**或者**复杂存储过程的查询**才会**占用大量内存**

##### 为操作系统保留内存

排除掉mysql使用的内存外,还需要**为操作系统保留内存**以使它能够完成基本的监控,配置,计划操作

##### InnoDB缓冲池

>  InnoDB缓冲池`非常依赖内存`,比其他任何组件都多

InnoDB**缓存索引**,**缓存行数据**,**自适应哈希索引**,**更改缓冲区**,**锁**,其他内部结构...

`必须要有足够的内存来分配给InnoDB`

查看缓冲池内存使用情况命令:

```sql
SHOW
```

###### 大型缓存池带来的弊端

大型缓存池会比小缓冲池的**关闭时间和预热时间更长**

> 如果缓存池中存在**脏页(修改过的)**,那么**可能需要更长的时间**

###### lazy行为

> 降低`innodb_max_dirty_pages_pct`变量值并**不能保证InnoDB保存更少的脏页**

相反,`innodb_max_dirty_pages_pct`会控制InnoDB的`lazy`行为

InnoDB默认**使用同一个后台线程**来刷新脏页,以及**合并写操作并按顺序执行**提高效率,这种行为就是`lazy`

该行为运行InnoDB**延迟刷新**缓冲池中的脏页,当脏页的**达到阈值**时,将会**快速刷新页面**

> 当mysq**l启动**后,缓**冲缓存是空**的,被成为**冷缓存**.需要通过**预热缓存池**以提高服务器自然填充缓冲池**更快的性能**

##### 线程缓存

缓冲池中保存了`当前没有与连接关联但已经准备好成为新连接的线程`

* 创建**新连接**时,如果缓冲池**中有空闲**的线程,那么mysql会**取出该线程**提供新连接.

* 当**连接关闭**时,如果缓冲池中还有**剩余空间**,那么mysql会将该线程**放回缓存**中

* 如果缓存中**满载**,那么mysql会**销毁该**线程

> `处于线程缓存或休眠状态的线程通常使用大约256kb内存`

#### 配置mysql的I/O行为

##### InnoDB事务日志

> InnoDB通过**日志来降低提交事务的成本**,它不会在每个事务提交时将缓冲池刷新到磁盘,而是记录到日志中.

InnoDB假设服务器使用的是传统磁盘,它会`将随机磁盘I/O转换为顺序I/O`.

`日志大小是固定的(通过innodb_log_file_size来控制)`,采用的是`循环写入`,一旦**达到**该日志文件的末尾,那么它会**回到日志的开头**.(所以为什么binlog都是1G左右的文件).如果日志记录中包含了**更改尚未应用到数据文件的事务**,那么将**无法覆盖日志**

##### 日志缓冲区

> InnoDB修改数据时会将**修改记录**写入日志缓冲区,并将其保存在内存中.

满足以下**任意条件**InnoDB会将缓冲区刷新到磁盘上的日志文件中

* 缓冲区满载
* 事务提交时
* 达到阈值(innodb_log_buffer_size指定的值)

> 通常日志缓冲区范围1-8mb

当InnoDB刷**新日志缓冲区到日志文件**时,会使用`互斥锁`锁定缓冲区,刷新日志并释放锁

InnoDB使用了`组提交特性`,提供在`单次I/O中将一组日志全部提交(`达到了多个事务同时准备刷新时的性能)

#### InnoDB表空间

>  InnoDB将**数据保存在表空间中**,表空间本质是一个**虚拟文件系统**.由文件上**一个或多个**文件组成

将表空间存储在不同的位置并不能提升太多性能,并且会导致冗余的垃圾.

即便通过`innodb_data_file_path`将表空间指定在多个不同的目录中,InnoDB还是会**将文件端到端串联起来**

> 不推荐使用`innodb_file_per_table`将每个表单独存储为一个文件,因为该命令会导致`DROP TABLE`性能变差

#### binlog配置

> **严禁**将`sync_binlog`设置为0
>
> 将sync_binlog设置为1的**安全性远程由此产生的I/O性能损失**
