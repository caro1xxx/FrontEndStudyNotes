#### 逻辑架构

![image-20230511222301272](/Users/wakeup/Library/Application Support/typora-user-images/image-20230511222301272.png)

1. 第一层客户端**并不是mysql独有**,大多数基于网络的客户端/服务器攻击都有类似的服务

2. 第二层**大多数mysql核心功能所处的位置(**查询解析,分析,优化,内置函数,触发器.视图等...)

3. 底层存储引擎,扶着mysql中的**数据读写**,服务器通过存储引擎API进行通信

   > 存储引擎API**抹平了不同存储引擎之间差异**,存储引擎不会去解析sql(InnoDB除外)
   >
   > 不同存储引擎之间**不会互相通信**

#### 连接管理与安全性

* 默认情况,**每个客户端连接**就会在服务器上**产生一个线程**
* 当客户端连接mysql时服务器会进行**鉴权**

#### 优化与执行

* 当有一条查询时,mysql解析查询以**创建内部数据结构树(解析树),并对其优化**
* **存储引擎对于查询优化有影响**
* Mysql8.0后提倡memcached或redis中缓存频繁请求的结果集(**使用内存数据库缓存频繁内容**)

#### 并发控制

> 无论何时,只要**多个操作一个对象一定会产生并发控制**

##### 读写锁

经典解决方案

* **共享锁(shared lock) 读锁**
* **排他锁(exclusive lock) 写锁**

> **时时刻刻都在发送锁**,当客户端修改数据时,mysql会锁定防止其他客户端读取,**锁的管理速度足够快,那么不会引起客户端感知**

##### 锁的粒度

> 锁的各种操作都需要消耗资源

大多数商业数据库都只是提供了通用的锁粒度,而mysql8.0提供了三种粒度

* 表锁
* 行锁
* 元数据锁(用于修改表名或schema)
* 应用程序级别锁(8.0新增)

表锁**能够节约性能**,相对的并发也就不行

> 表锁存在变体,在特定情况下提高性能,如READ LOCAL表锁支持并发写操作,写锁队列和读锁队列分开

行锁能**够提供更高的并发**,随之而来的就是高性能消耗

> 行锁由存储引擎实现,服务器通常不清楚存储引擎中的实现方式