事务就是一组sql语句

这一组语句作为**一个工作单元,**并且以**原子方式**进行处理

#### ACID

* 原子性(atomicity)
* 一致性(consistency)
* 隔离性(isolation)
* 持久性(durability)

#### 隔离级别

**较低**的隔离级别通常允许**更高的并发性,开销更低**

##### 四种隔离级别

![image-20230514125303023](/Users/wakeup/Library/Application Support/typora-user-images/image-20230514125303023.png)

###### READ UNCOMMITED(未提交读)

在级别下,事务中可以**查看其他事务中还没有提交的修改**

读取未提交的数据,称之为**脏读(dirty read)**

###### READ COMMITED(提交读)

一个事务**可以看到**其他事务在它**开始之后**的提交的修改.

在该事务**提交之前**,其所做的任何修改对**其他事务是不可见的**

> 允许不可重复读:
>
> **同一个事务**中**两次执行相同**语句,可能会**看到不同**的数据结果

###### REPEATABLE READ(可重复读)

可以重复读,保证了在同一个事务中多次读取相同行的结果一致

理论上,可重复读界别还是无法解决另外一个**幻读(phantom read)**问题

> 幻读产生的原因:当某个事务在读取**某个范围内**的记录时**,另外一个事务又在该范围插入**了新的记录,当**之前的事务再次读取该范围**的记录时,产生**幻行**(phantom row).
>
> 意思是之前的事务**无法读取到最新的记录**

>  REPEATABLE READ是mysql默认事务隔离界别

###### SERIALIZABLE(可串行)

最高隔离级别,通过**严格控制事务执行顺序**,使不同事务之间不可能出现冲突,从而解决幻读问题

该级别会在**读取的每一行数据上加上锁**

该级别可能会**导致大量的超时和锁争用问题**

#### 死锁

指**两个及以上的事务互相**持有和请求**相同资源上的锁**,从而产生**循环依赖**

数据库系统通常实现了**死锁检查和锁超时机制**

一旦发生死锁,**只有通过回滚其他一个事务(部分或全部),来打破死锁**

> InnoDB目前处理死锁的方式是将**持有最少级别排他锁的事务回滚**(最容易回滚的近似算法)

#### 事务日志

存储引擎通过修改内存中的数据副本,而不是每次修改磁盘中的表.

然后再把修改的记录写入事务日志,事务日志会被持久化保存在硬盘上

> 事务日志采用**追加写操作**,是在**硬盘**中的**一小块区域内顺序I/O**,而**不是多个地方随机I/O**,所以事务日志是相对较快的操作

#### mysql中的事务

##### autocommit

默认情况下,单个insert,update或delete语句会被**隐式包装在同一个事务中执行成功后立即提交**

可以禁用此模式,在事务中执行一系列语句,并在介绍时手动执行commit提交事务或rollback回滚事务

> 修改AUTOCOMMIT的指对非事务型的表不会有任何影响

##### 设置mysql中的隔离级别

```sql
set transaction isolation level
```

新的隔离级别**会在下一个事务开始的时候生效**

mysql可以识别4个ANSI标准的隔离级别

##### 在事务中混合使用存储引擎

在事务中混合使用事务表和非事务表,如果顺利,事务将会正常工作,但是如果需要回滚,则无法撤销对非事务表的修改

> 无论如何也不应该在应用程序中混合使用存储引擎,失败的事务可能导致不一致的效果

##### 隐式锁定和显示锁定

InnoDB使用**两阶段锁定协议**

* 在事务**执行期间**,随时可以获取锁
* 但是锁只有在**提交或回滚后才会释放**,并且所有锁**同时**释放

显示锁定(非sql语句)

```sql
select ... for share
select ... for update
```

