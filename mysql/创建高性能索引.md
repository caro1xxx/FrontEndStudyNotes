> 获取高性能,索引**至关重要**

#### 索引基础

当想看书中的某个内容时,一定是先看索引(也就是目录)找到对应的页码,mysql使用类似的方法.

> **使用ORM也需要关注索引**

mysql中的**索引是存储引擎层实现的**,并不是服务器层实现的

并没有同意的索引标准,不同存储引擎的索引工作方式并不一样.

##### 索引类型

###### B-tree索引

当人们谈论索引时,多半说的是B-tree

B-tree索引使用**B-tree数据结构来存储数据**

> 自适应哈希索引,InnoDB存储引擎有一个被称为自适应哈希索引的特性,当InnoDB**发现某些索引被频繁访问,那么它就会在原有B-tree索引上,在内存中构建一个哈希索引**,使得B-tree索引具备了一些哈希索引的优势.
>
> 自适应哈希索引在引擎内部自动完成无需配置.

B-tree适用于`全键值`,`键值范围`,`键前缀查找`

B-tree索引的限制

* 如果**不是按照索引的最左列开始查找**,则**无法使用索引**

* **不能跳过索引中的列**

* 如果查询中有某列的**范围查询**,则右边所有列都**无法使用索引优化**

  如查询中包含LIKE关键字,导致出现范围查询,那么整条查询都无法被优化

###### 全文索引

FULLTEXT是特殊类型索引,查找文本中的**关键字**,非直接比较索引中的值.

全文索引**更像搜索引擎做的事**,非简单的where条件匹配

##### 索引的优点

* **极大减少**了服务器需要**扫描的数据量**
* 可以帮助服务器**避免排序和临时表**
* 可以将`随机I/O变为顺序I/O`

#### 高性能索引策略

##### 前缀索引和索引选择性

* 在不降低索引的选择性之外保证最小索引空间

  索引选择性指:不重复的索引值

##### 多列索引

在多列上独立创建多个单列索引,大部分情况下都不会提高mysql查询性能

mysql引入了`索引合并(index merge)`策略

###### 索引合并

在一定程度上可以使用表中的多个单列索引来定位指定行,查询能够**同时使用两个单列索引**进行扫描,并将**结果进行合并**

该算法有三种变种

1. `OR`条件的联合
2. `AND`条件的相交
3. **组合**OR条件和AND条件

> `optimizer_switch`可以**关闭索引合并功能**

##### 选择合适的索引列顺序

当**不需要排序排序和分组时**,将**选择性最高的列放在前面**通常是最好的

##### 聚簇索引

聚簇索引并不是一种索引类型,而是`数据存储方式`

`聚簇`表示**数据行和相邻的键值紧凑地存储在一起.**

聚簇索引将表**数据存放在叶子页中**

聚簇索引`无法同时将数据行存放在两个不同的位置`,所以`一个表只能有一个聚簇索引`

> InnoDB根据**主键聚簇**数据,表示**mysql中索引列就是主键列**

如果**没有主键,**InnoDB会选择一个**唯一的非空索引代替.**

如果**没有这样的索引**,InnoDB会**隐式定义一个主键**来作为聚簇索引(可能会导致高锁竞争)

> 对于高并发的工作负载,
>
> 在InnoDB中`按主键顺序插入可能会造成明显的写入竞争`,主键的上界会成为"热点",因为索引的插入都发生在这里,所以并发插入可能导致间隙锁竞争
>
> 另外一个热点可能是`AUTO_INCREMENT锁机制`

##### 覆盖索引

如果一个索引包含所有需要查询的字段的值,称之为覆盖索引.

`只有B-tree索引可以用于覆盖索引`

##### 使用索引扫描来做排序

mysql有两种方式可以生成有序的结果:

* 通过排序
* 按索引顺序扫描

> 如果在EXPLAIN的输出结果中,type值为`index`,说明mysql使用了索引扫描来做排序

**按索引顺序读取数据**的速度通常**要比顺序地全盘扫描慢**

只有当**索引的顺序和order by子句的顺序完全一致**,并且**索引列的排序方向(正序或倒序)都一样**时,mysql才能使用**索引来对结果做排序**

