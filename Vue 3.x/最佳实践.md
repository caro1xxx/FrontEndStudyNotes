#### 为列表渲染设置属性key

> key特殊属性主要是在Vue的虚拟Dom算法中,在对比新旧虚拟节点时辨识虚拟节点
>
> 在使用v-for时提供key,以获取性能上的提升

```vue
<div v-for="index, item in items" :key="item.id">
    <!--内容-->
</div>
```

#### 在v-if/v-if-else/v-else中使用key

> 如果添加了属性key,那么在比对虚拟dom时,则会认为他们是两个不同的节点,**于是会将旧元素移出并在相同的位置添加一个新元素**,**从而避免意料之外的副作用**

```vue
<div
    v-if="error"
    key="status"
>
    {{内容}}
</div>
<div
     v-else
     key="results"
>  
     {{内容}}
</div>
```

#### 路由切换组件不变

> 典型问题:当页面**切换到同一个路由**但是**不同参数**的路由下,组件的**生命周期钩子不会**重新触发

> 这是因为vue-router会**识别出两个路由使用的是同一个组件从而进行复用**,并**不会**重新创建组件,因此组件的生命周期钩子**不会被触发**

> 组件本质是一个**映射关系**,所以先销毁再重建一个相同的组件会存在很大程度上的**性能浪费**,复用组件**才是正确的选择**,**但是这也意味着组件的生命周期钩子不会再被调用**

##### 路由导航守卫beforeRouteUpdate(**推荐**)

> 导航守卫beforeRouteUpdate,该守卫在**当前路由改变且组件被复用时调用**
>
> 只需要把**每次切换路由时需要执行**的逻辑放到beforeRouteUpdate守卫中即可

##### 观察$route对象的变化

> 通过**watch**可以**监听到路由对象发生的变化**,从而对路由变化作出响应

```js
watch:{
	'$route' (to, from) {
		//对路由变化作出的响应
	}
}
```

> 这种方法**虽然可以解决问题**,但是**带来了多一个watch的性能消耗**

##### 为router-view组件添加属性key

> 这种方法最简单,非常暴力,但有效,本质上是利用虚拟dom在渲染时通过key来对比两个节点是否相同的原理,通过给router-view设置key,可以使每次切换路由时的key都不一样,让虚拟dom认为router-view是一个新节点,从而先销毁组件,然后重新创建,即使是相同的组件,但是如果url变了,key变了,vue就会重新创建组件

> 缺点:每次切换组件时都会销毁并且重新创建,非常浪费性能

> 优点:简单粗暴,改动小,设置key之后,马上就能解决问题

```vue
<router-view :key="$route.fullPath"></router-view>
```

#### 避免在scoped中使用元素选择器

> 在scoped样式中,**类选择器比元素选择器更好**,因为大量的使用元素选择器是**很慢的**,为了**给样式设置作用域**,vue会**为元素添加一个独一无二的特性**,**如:data-v-f3f3eg9**,然后修改选择器,使得匹配选择器的元素中,只有带这个特性的才会真正生效

```vue
<template>
	<button class="btn">x</button>
</template>
<style scoped>
    .btn{
        xxxx:xxxx
    }
<style>
```

#### 单文件组件如何命名

> 单文件组件的命名虽然不会影响代码的正常运转,但是一个**良好的命名规范能够在绝大多数工程中改善可读性和开发体验**

##### 单文件组件的文件名的大小写

> 单文件组件的文件名**应该始终是单词首字母大写(**MyComponent)
>
> 或者始终是横线连接的(My-Component)

##### 基础组件名

> **应用特定样式和约定的基础**样式**(也就是展示类的,无逻辑的或无状态的组件**)应该全部以**一个特定的前缀开头,如:Base,App或V**.这些组件可以为你的应用奠定一致的基础样式行为

